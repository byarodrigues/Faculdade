
/********************************************************
 * typedfile.h - Trabalho - Árvore B                    *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#ifndef TYPEDFILE_H
#define TYPEDFILE_H

#include "header.h"
#include "record.h"
#include "serializable.h"
#include <string>
#include <fstream>
#include <type_traits>
#include "btree_node.h"

template <class T>
class typedFile : public std::fstream {
    static_assert(std::is_base_of<serializable, T>::value, "T must be serializable");
    template <class U> friend class record;  // Alterei para 'record'

public:
    typedFile();
    typedFile(const std::string& name, const std::string& type, const unsigned int version, std::ios::openmode openmode);
    ~typedFile();

    bool open(const std::string& name, const std::string& type, const unsigned int version, std::ios::openmode openmode);
    bool isOpen();
    bool close();
    bool clear();
    bool readRecord(record<T>& r, unsigned long long int i);  // Alterei para 'record'
    bool writeRecord(const record<T>& r, unsigned long long int i);  // Alterei para 'record'
    bool insertRecord(const record<T>& r);  // Alterei para 'record'
    bool deleteRecord(unsigned long long int i);
    unsigned long long int getFirstValid();
    unsigned long long int getFirstDeleted();
    unsigned long long int search(T data);
    bool readHeader(header& h);
    bool writeHeader(const header& h);
    void write(const serializable& obj);
    unsigned long long int index2pos(unsigned long long int i) {
    unsigned long long int pos2index(unsigned long long int p) {

private:
    std::string type;
    unsigned int version;
    bool fileIsValid(const std::string& type, const unsigned int version);
    unsigned long long int getRealFileSize();

};

template <class U>
class Record;

template <class T>
typedFile<T>::typedFile() : std::fstream() {
    static_assert(std::is_base_of<serializable, T>::value, "T must be serializable");
}

template <class T>
typedFile<T>::typedFile(const std::string& name, const std::string& type, const unsigned int version, std::ios::openmode openmode)
    : std::fstream(name.c_str(), openmode), type(type), version(version) {
    if (this->is_open()) {
        std::cout << "O arquivo está aberto" << std::endl;
    } else {
        std::cerr << "Erro ao abrir o arquivo." << std::endl;
        close();
    }
}

template <class T>
typedFile<T>::~typedFile() {
    if (this->is_open()) {
        this->close();
    }
}

template <class T>
bool typedFile<T>::open(const std::string& name, const std::string& type, const unsigned int version, std::ios::openmode openmode) {
    if (this->is_open()) {
        std::cerr << "Erro: O arquivo já está aberto." << std::endl;
        return false;
    }

    std::fstream::open(name.c_str(), openmode);

    if (!this->is_open()) {
        std::cerr << "Erro ao abrir o arquivo." << std::endl;
        return false;
    }

    // Logic to check if the file already exists and has the correct type and version
    if (!fileIsValid(type, version)) {
        std::cerr << "Erro: O arquivo não possui o tipo ou a versão corretos." << std::endl;
        this->close();
        return false;
    }

    return true;
}

template <class T>
bool typedFile<T>::isOpen() {
    return this->is_open();
}

template <class T>
bool typedFile<T>::close() {
    if (fstream::is_open()) {
        fstream::close();
        return true;
    }
    return false;
}

template <class T>
bool typedFile<T>::readRecord(record<T> &r, unsigned long long int i) {  // Alterei para 'record'
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Calcular a posição física do registro no arquivo
    unsigned long long int position = index2pos(i);

    // Mover o ponteiro de leitura para a posição calculada
    this->seekg(position, ios::beg);

    // Ler os dados brutos do registro do arquivo
    string rawData;
    getline(*this, rawData);

    // Desserializar os dados brutos para o registro
    r.deserialize(rawData);

    return true;
}


template <class T>
bool typedFile<T>::writeRecord(const record<T> &r, unsigned long long int i) {  // Alterei para 'record'
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Calcular a posição física do registro no arquivo
    unsigned long long int position = index2pos(i);

    // Mover o ponteiro de escrita para a posição calculada
    this->seekp(position, ios::beg);

    // Serializar o registro e escrever os dados brutos no arquivo
    string rawData = r.serialize();
    *this << rawData << endl;

    return true;
}

template <class T>
bool typedFile<T>::insertRecord(const record<T> &r) {  // Alterei para 'record'
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Mover o ponteiro de escrita para o final do arquivo
    this->seekp(0, ios::end);

    // Serializar o registro e escrever os dados brutos no arquivo
    string rawData = r.serialize();
    *this << rawData << endl;

    return true;
}

template <class T>
bool typedFile<T>::deleteRecord(unsigned long long int i) {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Calcular a posição física do registro no arquivo
    unsigned long long int position = index2pos(i);

    // Mover o ponteiro de escrita para a posição do registro
    this->seekp(position, ios::beg);

    // Sobrescrever o registro com uma marca de exclusão
    // (aqui estou usando um exemplo de marca, você pode ajustar conforme necessário)
    *this << "Registro Excluído" << endl;

    return true;
}

template <class T>
unsigned long long int typedFile<T>::getFirstValid() {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return 0; // ou outro valor de erro, dependendo dos requisitos do seu programa
    }

    header h;
    if (!readHeader(h)) {
        cerr << "Erro ao ler o cabeçalho." << endl;
        return 0; // ou outro valor de erro, dependendo dos requisitos do seu programa
    }

    return h.getFirstValid(); // supondo que o cabeçalho tenha um método para obter a posição do primeiro registro válido
}

template <class T>
unsigned long long int typedFile<T>::getFirstDeleted() {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return 0; // ou outro valor de erro, dependendo dos requisitos do seu programa
    }

    header h;
    if (!readHeader(h)) {
        cerr << "Erro ao ler o cabeçalho." << endl;
        return 0; // ou outro valor de erro, dependendo dos requisitos do seu programa
    }

    return h.getFirstDeleted(); // supondo que o cabeçalho tenha um método para obter a posição do primeiro registro deletado
}

template <class T>
unsigned long long int typedFile<T>::search(T data) {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return 0; // ou outro valor de erro, dependendo dos requisitos do seu programa
    }

    unsigned long long int currentIndex = 0;
    Record<T> currentRecord;

    // Iterar sobre os registros no arquivo
    while (readRecord(currentRecord, currentIndex)) {
        // Comparar os dados do registro com os dados fornecidos
        if (currentRecord.getData() == data) {
            // Se encontrar um registro com os dados correspondentes, retorna o índice
            return currentIndex;
        }

        currentIndex++;
    }

    // Se não encontrar o registro, retorna 0 ou outro valor de erro
    return 0; // ou outro valor de exemplo, substitua conforme necessário
}

template <class T>
bool typedFile<T>::readHeader(header &h) {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Mover o ponteiro de leitura para o início do arquivo
    this->seekg(0, ios::beg);

    // Ler os dados brutos do cabeçalho do arquivo
    string rawData;
    getline(*this, rawData);

    // Desserializar os dados brutos para o objeto Header
    h.fromString(rawData);

    return true;
}

template <class T>
bool typedFile<T>::writeHeader(const header &h) {
    if (!this->is_open()) {
        cerr << "Erro: O arquivo não está aberto." << endl;
        return false;
    }

    // Mover o ponteiro de escrita para o início do arquivo
    this->seekp(0, ios::beg);

    // Obter a representação de string do cabeçalho
    string headerString = h.toString();

    // Escrever os dados brutos do cabeçalho no arquivo
    *this << headerString << endl;

    return true;
}
// voltar aqui
/*************************************/

template <class T, unsigned int MIN_DEGREE>
unsigned long long int typedFile<T, MIN_DEGREE>::index2pos(unsigned long long int i) {
    if (!this->is_open()) {
        std::cerr << "Erro: O arquivo não está aberto." << std::endl;
        return 0;
    }

    // Salva o estado atual do cursor no arquivo
    std::streampos currentPosition = this->tellg();

    // Move o cursor para o final do arquivo para obter o tamanho real
    this->seekg(0, std::ios::end);
    unsigned long long int fileSize = this->tellg();

    // Restaura o cursor para a posição original
    this->seekg(currentPosition);

    return fileSize;
}

template <class T, const unsigned int MIN_DEGREE>
unsigned long long int typedFile<T, MIN_DEGREE>::pos2index(unsigned long long int p) {
    if (!this->is_open()) {
        std::cerr << "Erro: O arquivo não está aberto." << std::endl;
        return 0; // Ou algum valor que indique erro
    }

    size_t nodeSize = sizeof(BTreeNode<T, MIN_DEGREE>);  // Use a definição correta

    // Verificar se a posição fornecida ultrapassa o tamanho real do arquivo
    unsigned long long int fileSize = getRealFileSize(); // Substitua pela função real
    if (p >= fileSize) {
        std::cerr << "Erro: Posição fornecida ultrapassa o tamanho real do arquivo." << std::endl;
        return 0; // Ou algum valor que indique erro
    }

    // Ajuste da posição se necessário (por exemplo, se houver um cabeçalho no início do arquivo)
    // unsigned long long int adjustedPosition = p + headerSize; // Ajuste conforme necessário

    // Calcular o índice dividindo a posição física pelo tamanho do nó
    unsigned long long int index = p / nodeSize;

    // Considerar a estrutura específica da árvore B
    // Se necessário, ajuste o cálculo do índice com base na estrutura da árvore

    return index;
}

if (file.open("teste.dat", ios::in | ios::out | ios::binary)) {
    if (file.fileIsValid("BTreeFile", 1)) {
        cout << "O arquivo existe e possui o tipo e a versão corretos." << endl;
        // Realize operações adicionais, se necessário
    } else {
        cout << "O arquivo não possui o tipo ou a versão corretos." << endl;
        // Realize operações adicionais, se necessário
    }
} else {
    cout << "Erro ao abrir o arquivo." << endl;
    file.close();
}

#endif // TYPEDFILE_H

#######################################################################

/********************************************************
 * serializable.h - Trabalho - Árvore B                 *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#ifndef SERIALIZABLE_H
#define SERIALIZABLE_H

#include <iostream>
#include <string>
using namespace std;

class serializable {
public:
    serializable() {}
    virtual ~serializable() {}

    virtual void serialize(ostream &out) const = 0;
    virtual void deserialize(istream &in) = 0;
    virtual unsigned long long int size() const = 0;
};

#endif // SERIALIZABLE_H

######################################################################

/********************************************************
 * serialChar.cpp - Trabalho - Árvore B                 *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#include "serialChar.h"

serialChar::serialChar() : serializable() {
    this->data = 0;
}

serialChar::serialChar(char i) : serializable() {
    this->data = i;
}

serialChar::~serialChar() {
}

serialChar& serialChar::operator=(const serialChar& other) {
    if (this != &other) {  // Evita autoatribuição
        this->data = other.data;
    }
    return *this;
}

bool serialChar::operator==(const serialChar &other) const {
    return this->data == other.data;
}

bool serialChar::operator<(const serialChar &other) const {
    return this->data < other.data;
}

bool serialChar::operator<=(const serialChar &other) const {    // Verifica se this é menor que other ou se são iguais
    return this->data < other.data || this->data == other.data;
}

bool serialChar::operator>(const serialChar &other) const {    // Inverte a lógica do operador <
    return this->data > other.data;
}

bool serialChar::operator>=(const serialChar &other) const {    // Verifica se this é maior que other ou se são iguais
    return this->data > other.data || this->data == other.data;
}

bool serialChar::operator!=(const serialChar &other) const {    // Inverte a lógica do operador de igualdade
    return !(this->data == other.data);
}

serialChar serialChar::operator+(const serialChar& other) const {    // Cria uma nova instância concatenando os membros
    char result = this->data + other.data;

    // Retorna a nova instância
    return serialChar(result);
}

serialChar serialChar::operator-(const serialChar& other) const {    // Cria uma nova instância subtraindo os membros
    char result = this->data - other.data;

    // Retorna a nova instância
    return serialChar(result);
}

serialChar serialChar::operator*(const serialChar& other) const {    // Cria uma nova instância multiplicando os valores ASCII dos membros
    char result = this->data * other.data;

    // Retorna a nova instância
    return serialChar(result);
}

serialChar serialChar::operator/(const serialChar& other) const {    // Verifica se o divisor é zero para evitar uma possível divisão por zero
    if (other.data != 0) {
        // Cria uma nova instância dividindo os valores ASCII dos membros
        char result = this->data / other.data;

        // Retorna a nova instância
        return serialChar(result);
    } else {
        // Trate a divisão por zero conforme necessário
        // Aqui, poderia lançar uma exceção, retornar um valor padrão, etc.
        // Estou usando um caractere nulo ('\0') como exemplo.
        return serialChar('\0');
    }
}

serialChar serialChar::operator++() {    // Incrementa o valor ASCII do caractere
    ++this->data;

    // Retorna a instância após o incremento
    return *this;
}

serialChar serialChar::operator--() {    // Decrementa o valor ASCII do caractere
    --this->data;

    // Retorna a instância após o decremento
    return *this;
}

void serialChar::setValue(char v) {    // Atribui o valor a data
    this->data = v;
}

char serialChar::getValue() const {    // Retorna o valor do caractere
    return this->data;
}

unsigned long long int serialChar::size() const {    // Retorna o tamanho da instância em bytes
    return sizeof(this->data);
}

void serialChar::serialize(ostream &out) const {
    out.write(reinterpret_cast<const char*>(&data), sizeof(data));
}

void serialChar::deserialize(istream &in) {
    in.read(reinterpret_cast<char*>(&data), sizeof(data));
}

######################################################################

/********************************************************
 * serialChar.h - Trabalho - Árvore B                   *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#ifndef SERIALCHAR_H
#define SERIALCHAR_H

#include "serializable.h"
#include <iostream>

class serialChar : public serializable {
public:
    serialChar();
    serialChar(char i);
    ~serialChar();
    serialChar& operator=(const serialChar& other);
    bool operator==(const serialChar &other) const;
    bool operator<(const serialChar &other) const;
    bool operator<=(const serialChar &other) const;
    bool operator>(const serialChar &other) const;
    bool operator>=(const serialChar &other) const;
    bool operator!=(const serialChar &other) const;
    serialChar operator+(const serialChar& other) const;
    serialChar operator-(const serialChar& other) const;
    serialChar operator*(const serialChar& other) const;
    serialChar operator/(const serialChar& other) const;
    serialChar operator++();
    serialChar operator--();
    void setValue(char v);
    char getValue() const;
    virtual unsigned long long int size() const;
    void serialize(std::ostream& out) const;
    void deserialize(std::istream& in) override;

private:
    char data;
};

#endif // SERIALCHAR_H

######################################################################

/********************************************************
 * header.cpp - Trabalho - Árvore B                     *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#include "header.h"
#include <sstream>

header::header() : serializable() {
    // Inicialize os membros conforme necessário
    firstDeleted = 0; // ou o valor padrão desejado
    firstValid = 0;   // ou o valor padrão desejado
    type = "";        // ou o valor padrão desejado
    version = 1;      // ou a versão inicial desejada
}

header::header(const string t, unsigned int v) : serializable() {
    // Inicialize os membros conforme necessário
    firstDeleted = 0; // ou o valor padrão desejado
    firstValid = 0;   // ou o valor padrão desejado
    type = t;
    version = v;
}

header::header(const header &h) {
    // Copie os membros conforme necessário
    firstDeleted = h.firstDeleted;
    firstValid = h.firstValid;
    type = h.type;
    version = h.version;
}

header::~header() {
   //dtor
}

header& header::operator=(const header &h) {
    // Atribua os membros conforme necessário
    firstDeleted = h.firstDeleted;
    firstValid = h.firstValid;
    type = h.type;
    version = h.version;

    return *this;
}

bool header::operator==(const header &h) const {
    // Compare os membros e retorne true se forem iguais, caso contrário, false
    return (firstDeleted == h.firstDeleted &&
            firstValid == h.firstValid &&
            type == h.type &&
            version == h.version);
}

unsigned long long int header::getFirstDeleted() const {
    return firstDeleted;
}

void header::setFirstDeleted(unsigned long long int r) {
    firstDeleted = r;
}

unsigned long long int header::getFirstValid() const {
    return firstValid;
}

void header::setFirstValid(unsigned long long int r) {
    firstValid = r;
}

string header::getType() const {
    return type;
}

void header::setType(string t) {
    type = t;
}

unsigned int header::getVersion() const {
    return version;
}

void header::setVersion(unsigned int v) {
    version = v;
}

string header::toString() const {
    return to_string(firstDeleted) + "," + to_string(firstValid) + "," + type + "," + to_string(version);
}

void header::fromString(string repr) {
    stringstream ss(repr);
    string token;

    getline(ss, token, ',');
    firstDeleted = stoull(token);

    getline(ss, token, ',');
    firstValid = stoull(token);

    getline(ss, type, ',');

    getline(ss, token, ',');
    version = stoi(token);
}

unsigned long long int header::size() const {
    // Retorne o tamanho total da instância em bytes
    return sizeof(firstDeleted) + sizeof(firstValid) + type.size() + sizeof(version);
}

#######################################################################

#ifndef RECORD_H
#define RECORD_H

#include <string>
#include "serializable.h"
#include <type_traits>  // for std::is_base_of
#include <iostream>     // for std::ostream, std::istream

template <class T>
class record : public serializable {
    static_assert(std::is_base_of<serializable, T>::value, "T must be serializable");

public:
    record();
    record(T data);
    record(const record<T> &other);
    ~record();

    record<T> operator=(const record<T> &other);
    bool operator==(const record<T> &other) const;

    T getData() const;
    void setData(T data);

    unsigned long long int getNext() const;
    void setNext(unsigned long long int next);

    bool isDeleted() const;
    void del();
    void undel();

    unsigned long long int size() const override;

    // Métodos adicionados para a escrita e leitura de registros em arquivo
    void writeToFile(std::ostream &out) const override;
    void readFromFile(std::istream &in) override;

private:
    T data;
    unsigned long long int next;
    bool deleted;
};

template <class T>
record<T>::record() : serializable() {
    next = 0;
    deleted = false;
}

template <class T>
record<T>::record(T data) : serializable(), data(data) {
    next = 0;
    deleted = false;
}

template <class T>
record<T>::record(const record<T> &other) {
    data = other.data;
    next = other.next;
    deleted = other.deleted;
}

template <class T>
record<T>::~record() {}

template <class T>
record<T> record<T>::operator=(const record<T> &other) {
    if (this != &other) {
        data = other.data;
        next = other.next;
        deleted = other.deleted;
    }
    return *this;
}

template <class T>
bool record<T>::operator==(const record<T> &other) const {
    return (data == other.data && next == other.next && deleted == other.deleted);
}

template <class T>
T record<T>::getData() const {
    return data;
}

template <class T>
void record<T>::setData(T data) {
    this->data = data;
}

template <class T>
unsigned long long int record<T>::getNext() const {
    return next;
}

template <class T>
void record<T>::setNext(unsigned long long int next) {
    this->next = next;
}

template <class T>
bool record<T>::isDeleted() const {
    return deleted;
}

template <class T>
void record<T>::del() {
    deleted = true;
}

template <class T>
void record<T>::undel() {
    deleted = false;
}

template <class T>
unsigned long long int record<T>::size() const {
    return sizeof(data) + sizeof(next) + sizeof(deleted);
}

template <class T>
void record<T>::writeToFile(std::ostream &out) const {
    // Use os métodos de serialização da classe base
    serialize(out);

    // Escreva dados adicionais do registro no arquivo
    out.write(reinterpret_cast<const char*>(&next), sizeof(next));
    out.write(reinterpret_cast<const char*>(&deleted), sizeof(deleted));
}

template <class T>
void record<T>::readFromFile(std::istream &in) {
    // Use os métodos de desserialização da classe base
    deserialize(in);

    // Leia dados adicionais do registro do arquivo
    in.read(reinterpret_cast<char*>(&next), sizeof(next));
    in.read(reinterpret_cast<char*>(&deleted), sizeof(deleted));
}

#endif // RECORD_H

#######################################################################

#ifndef BTREE_NODE_H
#define BTREE_NODE_H

#include <iostream>
#include <vector>
#include "serializable.h"

template <class T, const unsigned int MIN_DEGREE>
class BTreeNode {
public:
    BTreeNode();
    ~BTreeNode();

    bool isLeaf() const;
    unsigned int size() const;
    void resize(unsigned int s);

    T getKey(int i) const;
    void setKey(T k, unsigned int i);
    void insertKey(T k);
    unsigned int findKey(T k) const;
    void removeKey(unsigned int i);
    void removeChild(unsigned int i);
    void insertNonFull(T k);

    BTreeNode<T, MIN_DEGREE>* getChild(unsigned int i);
    void setChild(BTreeNode<T, MIN_DEGREE>* c, unsigned int i);
    void insertChild(BTreeNode<T, MIN_DEGREE>* c);

    void splitChild(unsigned int i);
    void mergeChildren(unsigned int i);
    void performRotation(unsigned int i);

    void writeToDisk(std::ofstream& outFile);
    void readFromDisk(std::ifstream& inFile);
    void serialize(std::ofstream& outFile) const;
    void deserialize(std::ifstream& inFile);
    size_t getNodeSize() const;

private:
    static const unsigned int NOT_FOUND = -1;

    std::vector<T> keys;
    std::vector<BTreeNode<T, MIN_DEGREE>*> children;
};

template <class T, const unsigned int MIN_DEGREE>
BTreeNode<T, MIN_DEGREE>::BTreeNode() {}

template <class T, const unsigned int MIN_DEGREE>
BTreeNode<T, MIN_DEGREE>::~BTreeNode() {
    for (auto& child : children) {
        if (child != nullptr) {
            delete child;
            child = nullptr;  // Definir para nulo após excluir
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
bool BTreeNode<T, MIN_DEGREE>::isLeaf() const {
    return children.empty();
}

template <class T, const unsigned int MIN_DEGREE>
unsigned int BTreeNode<T, MIN_DEGREE>::size() const {
    return keys.size();
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::resize(unsigned int s) {
    if (s <= 2 * MIN_DEGREE - 1) {
        keys.resize(s);
        children.resize(s + 1);
    } else {
        throw std::out_of_range("Invalid size in resize");
    }
}

template <class T, const unsigned int MIN_DEGREE>
T BTreeNode<T, MIN_DEGREE>::getKey(int i) const {
    return keys[i];
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::setKey(T k, unsigned int i) {
    keys[i] = k;
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::insertKey(T k) {
    if (size() < 2 * MIN_DEGREE) {
        // O nó ainda tem espaço para a chave
        int i = size();

        // Encontrar a posição correta para a nova chave
        while (i > 0 && k < keys[i - 1]) {
            keys[i] = keys[i - 1];
            --i;
        }

        // Inserir a nova chave na posição correta
        keys[i] = k;
        resize(size() + 1);
    } else {
        // O nó está cheio, não pode acomodar mais chaves

        // Criar um novo nó para realizar a divisão
        BTreeNode<T, MIN_DEGREE>* newNode = new BTreeNode<T, MIN_DEGREE>();

        // Chamar a função de divisão, que ajustará os tamanhos e realizará a inserção
        splitChild(0);

        // Identificar em qual dos dois nós a nova chave deve ser inserida
        if (k < keys[0]) {
            getChild(0)->insertKey(k);
        } else {
            newNode->insertKey(k);
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
unsigned int BTreeNode<T, MIN_DEGREE>::findKey(T k) const {
    unsigned int i = 0;

    // Encontrar a posição correta para a chave
    while (i < size() && k > keys[i]) {
        ++i;
    }

    // Verificar se a chave foi encontrada
    if (i < size() && k == keys[i]) {
        return i;  // Chave encontrada, retorna o índice
    }

    return NOT_FOUND;  // Chave não encontrada
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::removeKey(unsigned int i) {
    if (i < size()) {
        // Deslocar as chaves à esquerda para cobrir o espaço da chave removida
        for (unsigned int j = i; j < size() - 1; ++j) {
            keys[j] = keys[j + 1];
        }

        // Decrementar o número de chaves no nó
        resize(size() - 1);
    } else {
        // Índice inválido
        throw std::out_of_range("Invalid index in removeKey");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::removeChild(unsigned int i) {
    if (i < children.size()) {
        delete children[i];
        children.erase(children.begin() + i);
    } else {
        // Índice inválido
        throw std::out_of_range("Invalid index in removeChild");
    }
}

template <class T, const unsigned int MIN_DEGREE>
BTreeNode<T, MIN_DEGREE>* BTreeNode<T, MIN_DEGREE>::getChild(unsigned int i) {
    if (i < size()) {
        return children[i];
    } else {
        // Índice inválido ou tentativa de acessar um filho inexistente
        throw std::out_of_range("Invalid index in getChild");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::setChild(BTreeNode<T, MIN_DEGREE>* c, unsigned int i) {
    if (i < size()) {
        children[i] = c;
    } else {
        // Índice inválido ou tentativa de definir um filho em uma posição inexistente
        throw std::out_of_range("Invalid index in setChild");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::insertChild(BTreeNode<T, MIN_DEGREE>* c) {
    if (children.size() + 1 <= 2 * MIN_DEGREE) {
        // O nó não está cheio e pode acomodar mais um filho
        children.push_back(c);
    } else {
        // Nó está cheio, não pode acomodar mais filhos
        throw std::overflow_error("Node cannot accommodate more children");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::splitChild(unsigned int i) {
    // Verifica se o índice é válido
    if (i < children.size() && children[i]->size() == 2 * MIN_DEGREE - 1) {
        // Cria um novo nó que será o nó direito após a divisão
        BTreeNode<T, MIN_DEGREE>* z = new BTreeNode<T, MIN_DEGREE>();

        // Obtém o nó que será dividido
        BTreeNode<T, MIN_DEGREE>* y = children[i];

        // Configura o novo nó como não folha se o nó dividido não for folha
        z->setLeaf(y->isLeaf());

        // Configura o número de chaves no novo nó
        z->resize(MIN_DEGREE - 1);

        // Move as chaves para o novo nó
        for (unsigned int j = 0; j < MIN_DEGREE - 1; ++j) {
            z->setKey(y->getKey(j + MIN_DEGREE), j);
        }

        // Move os filhos para o novo nó, se não for folha
        if (!y->isLeaf()) {
            for (unsigned int j = 0; j < MIN_DEGREE; ++j) {
                z->setChild(y->getChild(j + MIN_DEGREE), j);
            }
        }

        // Reduz o número de chaves no nó esquerdo
        y->resize(MIN_DEGREE - 1);

        // Move os filhos à direita de i em uma posição para acomodar o novo nó
        for (unsigned int j = size(); j > i; --j) {
            setChild(getChild(j - 1), j);
        }

        // Insere o novo nó como filho após o nó esquerdo
        setChild(z, i + 1);

        // Move a chave do meio do nó esquerdo para o nó atual
        insertKey(y->getKey(MIN_DEGREE - 1));

        // Incrementa o número de chaves no nó atual
        resize(size() + 1);

        // Supondo que DISK_WRITE realiza a operação de escrita no disco
        // DISK_WRITE(y);
        // DISK_WRITE(z);
        // DISK_WRITE(this);
    } else {
        // Índice inválido ou filho não está cheio
        throw std::out_of_range("Invalid index or child is not full in splitChild");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::mergeChildren(unsigned int i) {
    if (i < children.size() - 1) {
        BTreeNode<T, MIN_DEGREE>* leftChild = children[i];
        BTreeNode<T, MIN_DEGREE>* rightChild = children[i + 1];

        leftChild->insertKey(keys[i]);

        for (unsigned int j = 0; j < rightChild->size(); ++j) {
            leftChild->insertKey(rightChild->getKey(j));
        }

        if (!rightChild->isLeaf()) {
            for (unsigned int j = 0; j <= rightChild->size(); ++j) {
                leftChild->insertChild(rightChild->getChild(j));
            }
        }

        removeKey(i);
        removeChild(i + 1);

        delete rightChild;
        rightChild = nullptr;
    } else {
        throw std::out_of_range("Invalid index in mergeChildren");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::performRotation(unsigned int i) {
    if (i < children.size() - 1) {
        BTreeNode<T, MIN_DEGREE>* leftChild = children[i];
        BTreeNode<T, MIN_DEGREE>* rightChild = children[i + 1];
        leftChild->insertKey(keys[i]);
        setKey(rightChild->getKey(0), i);
        rightChild->removeKey(0);
        if (!rightChild->isLeaf()) {
            leftChild->insertChild(rightChild->getChild(0));
            rightChild->removeChild(0);
        }
    } else {
        throw std::out_of_range("Invalid index in performRotation");
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::writeToDisk(std::ofstream& outFile) {
    for (const auto& key : keys) {
        outFile.write(reinterpret_cast<const char*>(&key), sizeof(key));
    }

    for (const auto& child : children) {
        if (child != nullptr) {
            child->writeToDisk(outFile);
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::readFromDisk(std::ifstream& inFile) {
    for (auto& key : keys) {
        inFile.read(reinterpret_cast<char*>(&key), sizeof(key));
    }

    if (keys.size() != 2 * MIN_DEGREE - 1) {
        throw std::runtime_error("Error reading keys from disk");
    }

    if (!isLeaf()) {
        for (auto& child : children) {
            child = new BTreeNode<T, MIN_DEGREE>();
            child->readFromDisk(inFile);
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::serialize(std::ofstream& outFile) const {
    for (const auto& key : keys) {
        outFile.write(reinterpret_cast<const char*>(&key), sizeof(key));
    }

    for (const auto& child : children) {
        if (child != nullptr) {
            child->serialize(outFile);
        }
    }

    outFile.put('\n');  // Adicionar uma linha em branco para separar os nós no arquivo
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::deserialize(std::ifstream& inFile) {
    // Limpar chaves e filhos existentes, se houver
    keys.clear();
    children.clear();

    for (unsigned int i = 0; i < 2 * MIN_DEGREE - 1; ++i) {
        T key;
        inFile.read(reinterpret_cast<char*>(&key), sizeof(key));
        keys.push_back(key);
    }

    if (!isLeaf()) {
        for (unsigned int i = 0; i < 2 * MIN_DEGREE; ++i) {
            BTreeNode<T, MIN_DEGREE>* child = new BTreeNode<T, MIN_DEGREE>();
            child->deserialize(inFile);
            children.push_back(child);
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
size_t BTreeNode<T, MIN_DEGREE>::getNodeSize() const {
    size_t keySize = sizeof(T) * keys.size();
    size_t childPointerSize = sizeof(BTreeNode<T, MIN_DEGREE>*) * (children.size() + 1);
    size_t parentPointerSize = sizeof(BTreeNode<T, MIN_DEGREE>*);
    size_t currentSizeSize = sizeof(unsigned int);
    size_t additionalDataSize = sizeof(int);

    return keySize + childPointerSize + parentPointerSize + currentSizeSize + additionalDataSize;
}

#endif // BTREE_NODE_H

######################################################################

// mbtree.h

#ifndef MBTREE_H
#define MBTREE_H

#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include "btree_node.h"
#include "serializable.h"
using namespace std;

template <class T, const unsigned int MIN_DEGREE>
class mbtree {
public:
    mbtree();
    virtual ~mbtree();
    void insert(T k);
    void remove(T k);
    int search(BTreeNode<T, MIN_DEGREE>* x, T k);
    void print();
    void serialize(std::ofstream& outFile) const;
    void deserialize(std::ifstream& inFile);

protected:
    void insertNonFull(BTreeNode<T, MIN_DEGREE>* x, T k);
    void removeAux(BTreeNode<T, MIN_DEGREE>* x, T k);
    T findPredecessor(BTreeNode<T, MIN_DEGREE>* x);
    T findSuccessor(BTreeNode<T, MIN_DEGREE>* x);
    void printAux(BTreeNode<T, MIN_DEGREE>* x, vector<string>& v, unsigned int lvl);
    int searchAux(BTreeNode<T, MIN_DEGREE>* x, T k);
    void deleteSubtree(BTreeNode<T, MIN_DEGREE>* x);
    BTreeNode<T, MIN_DEGREE>* root = nullptr;
};

template <class T, const unsigned int MIN_DEGREE>
mbtree<T, MIN_DEGREE>::~mbtree() {
    if (root != nullptr) {
        deleteSubtree(root);
        root = nullptr;
    }
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::deleteSubtree(BTreeNode<T, MIN_DEGREE>* x) {
    if (x != nullptr) {
        for (auto& child : x->getChildren()) {
            deleteSubtree(child);
        }
        delete x;
    }
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::insert(T k) {
    if (root == nullptr) {
        root = new BTreeNode<T, MIN_DEGREE>();
    }

    if (root->size() == 2 * MIN_DEGREE - 1) {
        BTreeNode<T, MIN_DEGREE>* s = new BTreeNode<T, MIN_DEGREE>();
        root = s;
        s->setLeaf(false);
        s->resize(0);
        s->setChild(root, 0);
        s->splitChild(0);
        insertNonFull(s, k);
    } else {
        insertNonFull(root, k);
    }
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::remove(T k) {
    if (root != nullptr) {
        root->removeAux(k);

        if (root->size() == 0) {
            BTreeNode<T, MIN_DEGREE>* newRoot = root->getChild(0);
            delete root;
            root = newRoot;
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
int mbtree<T, MIN_DEGREE>::search(BTreeNode<T, MIN_DEGREE>* x, T k) {
    if (x != nullptr) {
        DISK_READ(x);
        return searchAux(x, k);
    }
    return -1;
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::print() {
    if (root != nullptr) {
        DISK_READ(root);
        vector<string> result;
        printAux(root, result, 0);

        for (const string& line : result) {
            cout << line << endl;
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
void BTreeNode<T, MIN_DEGREE>::insertNonFull(T k) {
    unsigned int i = size();

    if (isLeaf()) {
        while (i > 0 && k < getKey(i - 1)) {
            setKey(getKey(i - 1), i);
            i--;
        }

        setKey(k, i);
        resize(size() + 1);
        DISK_WRITE(this);
    } else {
        while (i > 0 && k < getKey(i - 1)) {
            i--;
        }

        i++;

        BTreeNode<T, MIN_DEGREE>* child = getChild(i - 1);

        if (child->size() == 2 * MIN_DEGREE - 1) {
            child->splitChild(i - 1);

            if (k > getKey(i - 1)) {
                i++;
            }
        }

        child = getChild(i - 1);
        child->insertNonFull(k);
    }
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::removeAux(BTreeNode<T, MIN_DEGREE>* x, T k) {
    unsigned int pos = x->findKey(k);
    T aux;

    if (x->isLeaf()) {
        if (pos != BTreeNode<T, MIN_DEGREE>::NOT_FOUND) {
            x->removeKey(pos);
            DISK_WRITE(x);
        }
    } else {
        if (pos != BTreeNode<T, MIN_DEGREE>::NOT_FOUND && !x->isLeaf()) {
            if (x->getChild(pos)->size() > MIN_DEGREE) {
                aux = findPredecessor(x->getChild(pos));
                x->getChild(pos)->removeAux(aux);
                x->setKey(aux, pos);
                DISK_WRITE(x);
            } else {
                if (x->getChild(pos + 1)->size() > MIN_DEGREE) {
                    aux = findSuccessor(x->getChild(pos + 1));
                    x->getChild(pos + 1)->removeAux(aux);
                    x->setKey(aux, pos);
                    DISK_WRITE(x);
                } else {
                    x->mergeChildren(pos);
                    DISK_WRITE(x);

                    if (x == root && x->size() == 0) {
                        root = x->getChild(pos);
                        delete x;
                        root->removeAux(k);
                    } else {
                        x->getChild(pos)->removeAux(k);
                    }
                }
            }
        } else {
            pos = 0;

            while (pos < x->size() && k > x->getKey(pos)) {
                pos++;
            }

            if (x->getChild(pos)->size() == MIN_DEGREE) {
                if (pos > 0 && x->getChild(pos - 1)->size() > MIN_DEGREE) {
                    x->rotateKeys(pos - 1);
                    DISK_WRITE(x);
                } else {
                    if (pos < x->size() && x->getChild(pos + 1)->size() > MIN_DEGREE) {
                        x->rotateKeys(pos);
                        DISK_WRITE(x);
                    } else {
                        if (pos == x->size()) {
                            x->mergeChildren(pos - 1);
                        } else {
                            x->mergeChildren(pos);
                        }

                        DISK_WRITE(x);

                        if (x == root && x->size() == 0) {
                            root = x->getChild(0);
                            delete x;
                            root->removeAux(k);
                        } else {
                            x->getChild(pos)->removeAux(k);
                        }
                    }
                }
            } else {
                x->getChild(pos)->removeAux(k);
            }
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
T mbtree<T, MIN_DEGREE>::findPredecessor(BTreeNode<T, MIN_DEGREE>* x) {
    while (!x->isLeaf()) {
        x = x->getChild(x->size() - 1);
    }

    return x->getKey(x->size() - 1);
}

template <class T, const unsigned int MIN_DEGREE>
T mbtree<T, MIN_DEGREE>::findSuccessor(BTreeNode<T, MIN_DEGREE>* x) {
    while (!x->isLeaf()) {
        x = x->getChild(0);
    }

    return x->getKey(0);
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::printAux(BTreeNode<T, MIN_DEGREE>* x, vector<string>& v, unsigned int lvl) {
    if (x != nullptr) {
        if (lvl >= v.size()) {
            v.resize(lvl + 1);
        }

        printAux(x->getChild(0), v, lvl + 1);

        stringstream ss;
        ss << x->getKey(0);
        v[lvl] += ss.str() + " ";

        for (unsigned int i = 1; i <= x->size(); ++i) {
            printAux(x->getChild(i), v, lvl + 1);
            if (i < x->size()) {
                stringstream ss;
                ss << x->getKey(i);
                v[lvl] += ss.str() + " ";
            }
        }
    }
}

template <class T, const unsigned int MIN_DEGREE>
int mbtree<T, MIN_DEGREE>::searchAux(BTreeNode<T, MIN_DEGREE>* x, T k) {
    unsigned int i = 0;

    while (i < x->size() && k > x->getKey(i)) {
        i++;
    }

    if (i < x->size() && k == x->getKey(i)) {
        return i;
    } else {
        if (!x->isLeaf()) {
            BTreeNode<T, MIN_DEGREE>* child = x->getChild(i);
            DISK_READ(child);
            return searchAux(child, k);
        }
    }

    return -1;
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::serialize(std::ofstream& outFile) const {
    if (root != nullptr) {
        DISK_READ(root);
        root->serialize(outFile);
    }
}

template <class T, const unsigned int MIN_DEGREE>
void mbtree<T, MIN_DEGREE>::deserialize(std::ifstream& inFile) {
    if (root != nullptr) {
        root->deserialize(inFile);
        DISK_READ(root);
    }
}

#endif // MBTREE_H

######################################################################

/********************************************************
 * header.h - Trabalho - Árvore B                     *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/

#ifndef HEADER_H
#define HEADER_H

#include "serializable.h"
#include <string>

using namespace std;

class header : public serializable {
public:
    header();
    header(const string t, unsigned int v);
    header(const header &h);
    ~header();

    header& operator=(const header &h);
    bool operator==(const header &h) const;

    unsigned long long int getFirstDeleted() const;
    void setFirstDeleted(unsigned long long int r);

    unsigned long long int getFirstValid() const;
    void setFirstValid(unsigned long long int r);

    string getType() const;
    void setType(string t);

    unsigned int getVersion() const;
    void setVersion(unsigned int v);

    string toString() const; // Certifique-se de que a declaração tem 'const'
    void fromString(string repr);

    unsigned long long int size() const;

private:
    unsigned long long int firstDeleted;
    unsigned long long int firstValid;
    string type;
    unsigned int version;
};

#endif // HEADER_H

######################################################################

/********************************************************
 * main.cpp - Trabalho - Árvore B                       *
 *                                                      *
 * Alunos: Beatriz Rodrigues de Oliveira Paiva          *
 *         RA: 0040300                                  *
 *                                                      *
 ********************************************************/
#include <iostream>
#include "mbtree.h"
#include "btree_node.h"  // Substitua pelo nome do arquivo que contém a definição da sua classe de nó
#include "typedfile.h"   // Substitua pelo nome do arquivo que contém a definição do TypedFile

int main() {
    // Criação e abertura do arquivo de dados
    typedFile<BTreeNode<char, 3>> dataFile;  // Substitua "BTreeNode" pelo nome da sua classe que representa os nós da árvore
    dataFile.open("arvoreB.dat", "tipo_do_no", 1, std::ios::in | std::ios::out | std::ios::binary);

    if (!dataFile.isOpen()) {
        std::cerr << "Erro ao abrir o arquivo de dados." << std::endl;
        return 1;
    }

    mbtree<char, 3> tree;  // Tipo de dado desejado.

    char testKeysInsert[] = {'u', '<', 'd', 'e', 'i', '{', '!', 'X', '.', '4', 'r', 'J', '#', 'B', '7', 'x', ',', '?', '9', ';', 'Q', '8', 'I', 'P', 'C'};
    char testKeysRemove[] = {'4', 'r', '#', ',', 'i', '<', 'e', '8', '9', 'C', '!', 'P'};
    char value;
    int choice;

    do {
        std::cout << "\nMenu:\n";
        std::cout << "1. Inserir valor na árvore B\n";
        std::cout << "2. Remover valor da árvore B\n";
        std::cout << "3. Imprimir árvore completa\n";
        std::cout << "4. Buscar valor na árvore B\n";
        std::cout << "5. Executar conjunto de testes padronizados\n";
        std::cout << "6. Sair\n";
        std::cout << "Escolha uma opção: ";

        while (!(std::cin >> choice) || choice < 1 || choice > 6) {
            std::cout << "Opção inválida. Tente novamente.\n";
            std::cin.clear();  // Limpa o estado de erro

            // Ignora caracteres inválidos até encontrar uma nova linha
            while (std::cin.get() != '\n') {
                continue;
            }
        }

        switch (choice) {
            case 1:
                std::cout << "Digite o valor a ser inserido na árvore B: ";
                std::cin >> value;
                tree.insert(value);
                std::cout << "Valor inserido com sucesso.\n";
                break;

            case 2:
                std::cout << "Digite o valor a ser removido da árvore B: ";
                std::cin >> value;
                tree.remove(value);
                std::cout << "Valor removido com sucesso.\n";
                break;

            case 3:
                std::cout << "Árvore B completa:\n";
                tree.print();
                break;

            case 4:
                std::cout << "Digite o valor a ser buscado na árvore B: ";
                std::cin >> value;

                if (tree.search(tree.getRoot(), value) != -1) {
                    std::cout << "O valor está na árvore B.\n";
                } else {
                    std::cout << "O valor não está na árvore B.\n";
                }
                break;

            case 5: {
                std::cout << "Executando conjunto de testes padronizados:\n";

                // Inserir na árvore B e imprimir estado atual
                for (char key : testKeysInsert) {
                    tree.insert(key);
                    std::cout << "Inserindo " << key << ": ";
                    tree.print();
                    std::cout << "\n";
                }

                // Remover da árvore B e imprimir estado atual
                for (char key : testKeysRemove) {
                    tree.remove(key);
                    std::cout << "Removendo " << key << ": ";
                    tree.print();
                    std::cout << "\n";
                }

                break;
            }

            case 6:
                std::cout << "Encerrando o programa.\n";
                break;
        }

    } while (choice != 6);

    dataFile.close();

    return 0;
}








quero que verifique se esse código faz a função pedida no trabalho(A árvore B em disco)

